클릭[2]
cars[2]
cars[,2]
Petal
boxplot(Petal.Length~Species,            # 자료와 그룹 정보 # ~Species를 주지 않으면 (데이터개수)150개를 petal.Length 하나로 그리게 될 거다. ~Species라는 column을 물결표시와 함께 지정했다. 그럼 이렇게 해석한다. sepecies별로 Petal.length를 가지고 boxplot을 그려라. 지금 species가 3개니까 각각 boxplot을 그린다고 보면 되겠다.
data=iris,                       # 자료가 저장된 자료구조
main='품종별 꽃잎의 길이',       # 그래프의 제목
col=c('green','yellow','blue'))  # 상자들의 색
iris$Species
as.numeric(iris$Species)
iris
install.packages("dplyr")
library(dplyr)
install.packages("ggplot2")
str(mpg)
str(mpg)
str(ggplot2::mpg)
str(ggplot2::mpg) #ggplot2의 mpg를 쓸 경우 패키지를 로드 안하고 쓸 거라면 이렇게 쓰면 된다. #tibble 타입인데 업그레이드된 데이터객체라고 생각하면 된다.
head(ggplot2::mpg) #위에 6개만 데이터를 보여줌. 어떤 컬럼명과 데이터 사이에 어떤 타입인지도 보여준다.
mpg <- as.data.frame(ggplot2::mpg)
exam
exam <- read.csv("data/csv_exam.csv") #수업에 사용할 csv 파일을 읽어오고 있다.
exam
#exam10.R 관련
#다음 문제들을 최대한 dplyr 패키지의 함수들과 %>% 기호(체인 함수)를 사용해서 해결하시오.
#data/emp.csv 의 내용을 읽어서 emp 변수를 생성한다.
emp <- read.csv(data/emp.csv)
#exam10.R 관련
#다음 문제들을 최대한 dplyr 패키지의 함수들과 %>% 기호(체인 함수)를 사용해서 해결하시오.
#data/emp.csv 의 내용을 읽어서 emp 변수를 생성한다.
emp <- read.csv("data/emp.csv")
emp
emp
library(dplyr) # detach("package:dplyr") 는 패키지에 대해서만 쓰는게 아니라 데이터에 대해서도 쓴다. 로드되어있던 API를 해제하는 기능이다.
library(dplyr) # detach("package:dplyr") 는 패키지에 대해서만 쓰는게 아니라 데이터에 대해서도 쓴다. 로드되어있던 API를 해제하는 기능이다.
install.packages("tidyr") # 추가
library(tidyr)
library(dplyr)
library(dplyr) # detach("package:dplyr") 는 패키지에 대해서만 쓰는게 아니라 데이터에 대해서도 쓴다. 로드되어있던 API를 해제하는 기능이다.
#exam10.R 관련
#다음 문제들을 최대한 dplyr 패키지의 함수들과 %>% 기호(체인 함수)를 사용해서 해결하시오.
#data/emp.csv 의 내용을 읽어서 emp 변수를 생성한다.
emp <- read.csv("data/emp.csv")
emp
#[문제1] 직무가 MANAGER 인 직원들의 정보를 출력한다.
emp %>% filter(job == "MANAGER")
#[문제2] emp 에서 사번, 이름, 월급을 출력한다.
exam %>% select(empno, name, sal)
#[문제2] emp 에서 사번, 이름, 월급을 출력한다.
emp %>% select(empno, name, sal)
#[문제2] emp 에서 사번, 이름, 월급을 출력한다.
emp %>% select(empno, name, sal)
#[문제2] emp 에서 사번, 이름, 월급을 출력한다.
emp %>% select(empno, ename, sal)
#[문제3] emp 에서 사번만 빼고 출력한다.
emp %>% select(-empno)
#[문제2] emp 에서 사번, 이름, 월급을 출력한다.
emp %>% select(이름 = empno, ename, sal)
#[문제2] emp 에서 사번, 이름, 월급을 출력한다.
emp %>% select(사번 = empno, 이름 = ename, 월급 = sal) #해봤는데 됨
#[문제4] emp 에서 ename 과 sal컬럼만 출력한다.
emp %>% select(ename, sal)
#[문제5] 직무별 직원수를 출력한다.
emp %>% count(job)
#[문제6] 월급이 1000 이상이고 3000이하인 사원들의 이름, 월급, 부서번호를 출력한다.
emp %>% filter(sal >=1000 & sal <= 3000) %>% select(ename, sal, deptno)
#[문제7] emp 에서 직무가 ANALYST 가 아닌 사원들의 이름, 직무, 월급을 출력한다.
emp %>% filter(job != ANALYST) %>% select(ename, job, sal)
#[문제7] emp 에서 직무가 ANALYST 가 아닌 사원들의 이름, 직무, 월급을 출력한다.
emp %>% filter(job != "ANALYST") %>% select(ename, job, sal)
cat("정상 수행..\n")
#[문제8] emp 에서 직무가 SALESMAN 이거나 ANALYST 인 사원들의 이름, 직무를 출력한다.
emp %>% filter(job == ("ANALYST" | "SALESMAN")) %>% select(ename, job)
#[문제8] emp 에서 직무가 SALESMAN 이거나 ANALYST 인 사원들의 이름, 직무를 출력한다.
emp %>% filter(job == "ANALYST" | job == "SALESMAN") %>% select(ename, job)
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% count(job) %>% summary(s = sum())
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% count(job) %>% summarise(s = sum())
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% count(deptno) %>% summarise(s = sum())
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% count(deptno) %>% select(sal)
group_by(deptno)
emp %>% group_by(deptno)
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% group_by(deptno) %>% select(sal)
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% group_by(deptno) %>% summarise(sum_sal = sum(sal))
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% group_by(부서번호 = deptno) %>% summarise(월급 = sum(sal))
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% group_by(부서번호 = deptno) %>% summarise(월급 총합 = sum(sal))
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% group_by(부서번호 = deptno) %>% summarise(월급총합 = sum(sal))
#[문제10] 월급이 적은 순으로 모든 직원 정보를 출력한다.
emp %>% arrange(sal)
#[문제11] 월급이 제일 많은 직원의 정보를 출력한다.
emp %>% arrange(desc(sal)) %>% head(1)
emp %>% rename(sal = salary, comm = commrate)
emp %>% rename(salary = sal, commrate = comm)
#[문제12] 직원들의 월급을 보관하고 있는 컬럼의 컬럼명을 sal에서 salary 로 변경하고
#커미션 정보 저장한 컬럼의 컬럼명를 comm 에서 commrate 로 변경한 후 empnew 라는 새로운 데이터셋을 생성한다.
empnew <- emp %>% rename(salary = sal, commrate = comm)
empnew
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange(desc(sal)) >%> head(1)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange(desc(sal)) %>% head(1)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange() %>% head(1)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange(desc()) %>% head(1)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange(desc()) %>% head(1)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange() %>% head(-1)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange() %>% head(-1)
emp %>% count(deptno)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% arrange(desc(count(deptno))) %>% head(-1)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% arrange(desc(count(deptno)))
emp %>% arrange(desc(deptno))
emp %>% arrange(desc(deptno)) %>% count()
emp %>% count(deptno)
emp %>% count(deptno) %>% arrange()
emp %>% count(deptno) %>% arrange(desc())
emp %>% count(deptno) %>% arrange(desc(n))
emp %>% arrange(desc(count(deptno)))
emp %>% count(deptno) %>% arrange(desc(n)) > head(1)
emp %>% count(deptno) %>% arrange(desc(n)) %>% head(1)
#[문제14] 각 직원들 이름의 문자 길이를 저장하는 enamelength 라는 컬럼을 추가한 다음에 이름 길이가 짧은 순으로 직원의 이름을 출력한다.
emp %>% mutate(enamelength = nchar(ename))
#[문제14] 각 직원들 이름의 문자 길이를 저장하는 enamelength 라는 컬럼을 추가한 다음에 이름 길이가 짧은 순으로 직원의 이름을 출력한다.
emp %>% mutate(enamelength = nchar(ename)) %>% arrange(enamelength)
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% count(comm)
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% filter(comm != NA)
emp
emp
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% count(comm) %>% filter(comm != NA)
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% count(comm)
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% count(comm) %>% filter(comm != "NA")
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% count(comm) %>% filter(comm != "NA")
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% filter(comm != "NA") %>% count(comm)
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% filter(comm != "NA") %>% count(comm) %>%  summarise(sum(n))
#다음 문제들을 최대한 dplyr 패키지의 함수들과 %>% 기호(체인 함수)를 사용해서 해결하시오.
#data/emp.csv 의 내용을 읽어서 emp 변수를 생성한다.
emp <- read.csv("data/emp.csv")
#[문제1] 직무가 MANAGER 인 직원들의 정보를 출력한다.
emp %>% filter(job == "MANAGER")
#[문제2] emp 에서 사번, 이름, 월급을 출력한다.
emp %>% select(사번 = empno, 이름 = ename, 월급 = sal) #해봤는데 됨
#[문제3] emp 에서 사번만 빼고 출력한다.
emp %>% select(-empno)
#[문제4] emp 에서 ename 과 sal컬럼만 출력한다.
emp %>% select(ename, sal)
#[문제5] 직무별 직원수를 출력한다.
emp %>% count(job)
#[문제6] 월급이 1000 이상이고 3000이하인 사원들의 이름, 월급, 부서번호를 출력한다.
emp %>% filter(sal >=1000 & sal <= 3000) %>% select(ename, sal, deptno)
#[문제7] emp 에서 직무가 ANALYST 가 아닌 사원들의 이름, 직무, 월급을 출력한다.
emp %>% filter(job != "ANALYST") %>% select(ename, job, sal)
#[문제8] emp 에서 직무가 SALESMAN 이거나 ANALYST 인 사원들의 이름, 직무를 출력한다.
emp %>% filter(job == "ANALYST" | job == "SALESMAN") %>% select(ename, job)
#[문제9] 부서별 직원들 월급의 합을 출력한다.
emp %>% group_by(부서번호 = deptno) %>% summarise(월급총합 = sum(sal))
#[문제10] 월급이 적은 순으로 모든 직원 정보를 출력한다.
emp %>% arrange(sal)
#[문제11] 월급이 제일 많은 직원의 정보를 출력한다.
emp %>% arrange(desc(sal)) %>% head(1)
#[문제12] 직원들의 월급을 보관하고 있는 컬럼의 컬럼명을 sal에서 salary 로 변경하고
#커미션 정보 저장한 컬럼의 컬럼명를 comm 에서 commrate 로 변경한 후 empnew 라는 새로운 데이터셋을 생성한다.
empnew <- emp %>% rename(salary = sal, commrate = comm)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange(desc(n)) %>% head(1)
#[문제14] 각 직원들 이름의 문자 길이를 저장하는 enamelength 라는 컬럼을 추가한 다음에 이름 길이가 짧은 순으로 직원의 이름을 출력한다.
emp %>% mutate(enamelength = nchar(ename)) %>% arrange(enamelength) #nchar은 exam8.R
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% filter(comm != "NA") %>% count(comm) %>%  summarise(sum(n))
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange(desc(n)) %>% head(1)
#[문제13] 가장 많은 인원이 일하고 있는 부서 번호를 출력한다.
emp %>% count(deptno) %>% arrange(desc(n)) %>% head(1) %>% select(deptno)
#[문제14] 각 직원들 이름의 문자 길이를 저장하는 enamelength 라는 컬럼을 추가한 다음에 이름 길이가 짧은 순으로 직원의 이름을 출력한다.
emp %>% mutate(enamelength = nchar(ename)) %>% arrange(enamelength) #nchar은 exam8.R
#[문제14] 각 직원들 이름의 문자 길이를 저장하는 enamelength 라는 컬럼을 추가한 다음에 이름 길이가 짧은 순으로 직원의 이름을 출력한다.
emp %>% mutate(enamelength = nchar(ename)) %>% arrange(enamelength) %>% select(ename) #nchar은 exam8.R
emp %>% filter(!is.na(comm)) %>% summarise(comm = n())
#[문제15] 커미션이 정해진 직원들의 명수를 출력한다.
emp %>% filter(comm != "NA") %>% count(comm) %>%  summarise(sum(n))
emp %>% filter(!is.na(comm)) %>% tally()
mpg
# 학생 1~5번 시험 데이터(프레임) 생성
(group_a <- data.frame(id = c(1, 2, 3, 4, 5),  test = c(60, 80, 70, 90, 85)))
# 학생 6~10번 시험 데이터(프레임) 생성
(group_b <- data.frame(id = c(6, 7, 8, 9, 10),  test = c(70, 83, 65, 95, 80)))
bind_rows(group_a, group_b)
bind_cols(group_a, group_b)
df <- data.frame(sex = c("M", "F", NA, "M", "F"),
score = c(5, 4, 3, 4, NA))
View(df)
df <- data.frame(sex = c("M", "F", NA, "M", "F"),
score = c(5, 4, 3, 4, NA))
View(df)
# 결측치 확인하기
is.na(df)         # 결측치 확인
# 결측치가 하나라도 있으면 제거하기
df_nomiss2 <- na.omit(df)  # 모든 변수에 결측치 없는 데이터 추출 #데이터 프레임 내에 모든 결측치(NA)를 제거한다.
df_nomiss2
library(tidyr)
library(dplyr)
exam <- read.csv("data/csv_exam.csv")
exam[c(1, 5, 3, 8, 15, 20), "math"] <- NA
exam
fill(exam, math, .direction = "down") # 바로 위의 데이터를 내려서 결측치(NA)를 채운다.#fill()은 tidyr패키지에서 제공한다. #이렇게 하면 맨 위의 행은 NA를 다른 값으로 채우지 못한다.
fill(exam, math, .direction = "up") # 바로 아래의 데이터를 올려서 결측치(NA)를 채운다. #이렇게 하면 맨 아래의 행은 NA를 다른 값으로 채우지 못한다.
fill(exam, math, .direction = "updown")
nums1 <- 1:10
boxplot(nums1)
boxplot.stats(nums1) #최솟값, 2사분위, 3사분위, 최댓값, 중간값, 평균 등
mpg <- as.data.frame(pplot2::mpg)
#11/11 실습2
library(dplyr)
mpg <- as.data.frame(pplot2::mpg)
#문제 1 답안코드
mpg <- as.data.frame(ggpplot2::mpg)
#문제 1 답안코드
mpg <- as.data.frame(ggpplot2::mpg)
#11/11 실습2
library(dplyr)
#문제 1 답안코드
mpg <- as.data.frame(ggpplot2::mpg)
#문제 1 답안코드
mpg <- as.data.frame(ggplot2::mpg)
str(mpg)
dim(mpg)
mpg %>% head(10)
mpg %>% tail(10)
View(mpg)
install.packages("xlsx")
library(xlsx)
install.packages("gridExtra")
install.packages("plotly")
install.packages("treemap")
data(mtcars) #내장되어있는 mtcars라는 데이터셋을 (다시)읽어오겠다. #만약 이전에 시동해서 값이 바뀌었다면 이걸 출력해서 다시 초기화 상태를 읽어옴.
head(mtcars) #mtcars라는 애의 헤드(상위 6개) #mtcars가 어떤애인지 알고 싶으면 드래그->Help 클릭
mpg <- as.data.frame(ggplot2::mpg)
#install.packages("ggplot2") # ggplot2 패키지 설치 #이미 설치했음
library(ggplot2)
library(dplyr)
mpg <- as.data.frame(ggplot2::mpg)
str(mpg)
ggplot2::mpg
mpg
ggplot(mpg)
ggplot(mpg,aes(displ, hwy))
mpg <- as.data.frame(ggplot2::mpg)
str(mpg)
ggplot(mpg)
sketch <- ggplot(data = mpg, aes(x = displ, y = hwy)) #x 축은 displ, y축은 hwy라는 데이터계층을 미리 호출을 해서 밑바탕이 되는 데이터레이어만 그려질텐데 변수에 담는 경우는 sketch라는 변수에 담았는데 그럼 화면에 보이지 않는다.(뭔소린지 이해가..)
str(sketch)
sketch
sketch + geom_point()
sketch + geom_line(color="green")
sketch + geom_point() + xlim(3, 6)
geom_point(aes(color=drv)
sketch + geom_point(aes(color=drv)) #sketch라는 변수 안에는 리스트 객체가 들어있는데
sketch + geom_point(size=3) + coord_cartesian(xlim=c(3, 6), ylim=c(10, 30)) #x축과 y축의 범위는 '+' 연산자로 주던가 coord_cartesian()이라는 함수의 argument로 x축과 y축의 범위를 주는 것도 가능하다.
sketch + geom_point(aes(color=drv)) #sketch라는 변수 안에는 리스트 객체가 들어있는데
(df_mpg <- mpg %>% group_by(drv) %>% summarise(mean_hwy = mean(hwy)))  #그룹핑을 하는데 그룹핑을 하면 tibble 객체로 만들어진다.
# 집계 막대 그래프 - 미리 집계해서 인수로 전달하면 이 값으로 바그래프 그림 #높이만큼 그려짐
ggplot(data = df_mpg, aes(x = drv, y = mean_hwy)) + geom_col() #x축은 색의 drv가 되고 y축은 고속도로연비의 평균값(mean_hwy)이 되는 거다. #104번째 라인에서 미리 집계를 냈기 때문에 집계막대그래프라고 한다.
# 빈도 막대 그래프 - 행의 갯수를 그려서 바그래프 그림
ggplot(data = mpg, aes(x = drv)) + geom_bar() #행의 개수를 세서 개수만큼 맞게 높이로 그려준다. #x축은 drv. #geom_bar()은 빈도 막대 그래프를 그려주는데 (ggplot()에서)y축은 따로 지정해주지 않는다.
# 상자 그림
ggplot(data = mpg, aes(x = drv, y = hwy)) + geom_boxplot()
# 선 그래프
ggplot(data = economics, aes(x = date, y = unemploy)) + geom_line()
str(economics)
ggplot(mtcars, aes(x=cyl)) + geom_bar() #geom_bar는 카운트해서 바 그래프 그려주는 거다. #3-5짜리는 4개,
ggplot(mtcars, aes(x=cyl)) + geom_bar(width=0.5)
ggplot(mtcars, aes(x=cyl, fill=factor(gear))) + geom_bar(alpha=0.5) #fill=factor(gear)은 gear 데이터값으로 채우는데 그 값을 numeric으로 인식하지말고 factor로 인식하라는 것이다.
ggplot(mtcars, aes(x=cyl)) + geom_bar(aes(fill=factor(gear)), alpha=1.0) #alpha는 투명도를 의미한다. 0.0은 완전투명, 1.0은 완전 불투명
ggplot(mtcars, aes(x=cyl)) + geom_bar(aes(fill=factor(gear)), alpha=1.0) #alpha는 투명도를 의미한다. 0.0은 완전투명, 1.0은 완전 불투명
ggplot(mtcars, aes(x=cyl)) + geom_bar(width=0.5)
Temp
Temp
str(airquality) #내장객체인 airquality는 앞에서 한 번 정도 접해봤다. 1973년 뉴욕의 공기질을 측정한 것이다.
View(airquality) #한 눈에 보기 표로 쉽게 정리해줌.
bar_data <- classDF[3] #3번째 데이터(3번째 열인 혈액형)만 추출 #이렇게 꺼내면 데이터프레임 형태를 유지하면서 꺼낸다.
bar_data
classDF <- read.xlsx("data/data.xlsx", 1, encoding="UTF-8") #1은 첫번째 시트를 읽어라. #엑셀은 MS949가 기본인데 그걸 UTF-8로 읽으라고 지정해준 것. #첫번째 시트는 이름, 성별, 혈액형 #두번째 시트는 트리맵 테스트할때 사용하게 되는 데이터셋으로 "판매상품"과 "어느 지역"에서 "얼만큼 팔렸는지"
library(xlsx)
classDF <- read.xlsx("data/data.xlsx", 1, encoding="UTF-8") #1은 첫번째 시트를 읽어라. #엑셀은 MS949가 기본인데 그걸 UTF-8로 읽으라고 지정해준 것. #첫번째 시트는 이름, 성별, 혈액형 #두번째 시트는 트리맵 테스트할때 사용하게 되는 데이터셋으로 "판매상품"과 "어느 지역"에서 "얼만큼 팔렸는지"
str(classDF)
View(classDF)
bar_data <- classDF[3] #3번째 데이터(3번째 열인 혈액형)만 추출 #이렇게 꺼내면 데이터프레임 형태를 유지하면서 꺼낸다.
bar_data
bar_data <- classDF[,3] #3번째 데이터(3번째 열인 혈액형)만 추출 #이렇게 꺼내면 데이터프레임 형태를 유지하면서 꺼낸다.
bar_data
ggplot(classDF, aes(x=bloodType)) + geom_bar(aes(fill=gender)) #혈액형으로 x축을 정하고(aes(x=bloodType)), 각각의 막대를 성별로 채운다(geom_bar(aes(fill=gender)).
ggplot(bar_data, aes(x=bloodType)) + geom_bar()
table(bar_data$bloodType) #혈액형이 각각 몇개인지 세서 출력해준다.
ggplot(bar_data, aes(x=bloodType)) + geom_bar()
ggplot(classDF, aes(x=bloodType)) + geom_bar(aes(fill=gender)) #혈액형으로 x축을 정하고(aes(x=bloodType)), 각각의 막대를 성별로 채운다(geom_bar(aes(fill=gender)).
bar_data <- classDF[3] #3번째 데이터(3번째 열인 혈액형)만 추출 #이렇게 꺼내면 데이터프레임 형태를 유지하면서 꺼낸다. #만약 classDF[,3]으로 했으면 벡터형으로 꺼내진다.
bar_data #열이 하나짜리인 데이터프레임 생성
str(bar_data)
table(bar_data$bloodType) #혈액형이 각각 몇개인지 세서 출력해준다.
ggplot(bar_data, aes(x=bloodType)) + geom_bar()
ggplot(classDF, aes(x=bloodType)) + geom_bar(aes(fill=gender)) #혈액형으로 x축을 정하고(aes(x=bloodType)), 각각의 막대를 성별로 채운다(geom_bar(aes(fill=gender)).
ggplot(bar_data, aes(x=bloodType)) + geom_bar()
ggplot(bar_data, aes(x=bloodType)) + geom_bar()
# 라인차트 생성 - x축은 연도(year), y축은 매출(sales) 매칭
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line()
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(aes(group=company))
# A, B회사의 매출 실적 데이터프레임 만들기
company <- c('A', 'A', 'A', 'A', 'B', 'B', 'B', 'B')
year <- c('1980', '1990', '2000', '2010', '1980', '1990', '2000', '2010')
sales <- c(2750, 2800, 2830, 2840, 2760, 2765, 2775, 2790)
coSalesDF <- data.frame(company, year, sales) #데이터 프레임 생성
# 생성된 coSalesDF 확인
View(coSalesDF)
str(coSalesDF)
# 라인차트 생성 - x축은 연도(year), y축은 매출(sales) 매칭
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line()
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(aes(group=company))
# 선 색상 및 두께 설정
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company,colour=company)) #회사별로 그룹핑을 하고 색상에다가 company를 준다. 색상은 'color', 'col', 'colour' 다 된다.
drv
# 점의 종류와 색상
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company, colour=company)) + geom_point(linewidth=2, shape = 5)
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company, colour=company)) + geom_point(size=2, shape = '가', colour = "Red")
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company, colour=company)) + geom_point(size=2, shape = '가')
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company, colour=company)) + geom_point(size=2, shape = '가', colour = "Red")
# 점의 종류와 색상
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company, colour=company)) + geom_point(size=2, shape = 5)
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company, colour=company)) + geom_point(size=2, shape = '가')
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company, colour=company)) + geom_point(size=2, shape = '가', colour = "Red")
# 선 색상 및 두께 설정
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company)) #회사별로 그룹핑을 하고 색상에다가 company를 준다. 색상은 'color', 'col', 'colour' 다 된다.
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company))+scale_colour_grey()
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company))+scale_colour_hue()
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company))+scale_colour_manual(values = c("orange", "green")) #지정하고싶은 색상을 벡터로 만든다.
# 선의 종류 :  0 = blank, 1 = solid, 2 = dashed, 3 = dotted, 4 = dotdash, 5 = longdash, 6 = twodash
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company), linetype = 3) #3이면 dotted
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company), linetype = "dotdash") #숫자 대신 실제 값으로 줘도 된다.
# 점의 종류와 색상
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company, colour=company)) + geom_point(size=2, shape = 5) #size대신 linewidth 쓰라고 에러떴는데 여기서는 왜인지 안 바꿔도 됨
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company, colour=company)) + geom_point(size=2, shape = '가')
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company, colour=company)) + geom_point(size=2, shape = '가', colour = "Red")
library(MASS)
# 선 색상 및 두께 설정
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company,colour=company)) #회사별로 그룹핑을 하고 색상에다가 company를 준다. 색상은 'color', 'col', 'colour' 다 된다.
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company))+scale_colour_grey()
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(size=2, aes(group=company,colour=company), linetype = "dotdash") #숫자 대신 실제 값으로 줘도 된다.
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company), linetype = "dotdash") #숫자 대신 실제 값으로 줘도 된다.
# 선의 종류 :  0 = blank, 1 = solid, 2 = dashed, 3 = dotted, 4 = dotdash, 5 = longdash, 6 = twodash
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company), linetype = 3) #3이면 dotted
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company), linetype = "dotdash") #숫자 대신 실제 값으로 줘도 된다.
# 선의 종류 :  0 = blank, 1 = solid, 2 = dashed, 3 = dotted, 4 = dotdash, 5 = longdash, 6 = twodash
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company), linetype = 3) #3이면 dotted
ggplot(coSalesDF, aes(x=year, y=sales)) + geom_line(linewidth=2, aes(group=company,colour=company), linetype = "dotdash") #숫자 대신 실제 값으로 줘도 된다.
ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, size=6) #만약 로드를 안 했다면 Cars93마다 MASS를 붙여야 한다.
ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, size=6, colour="blue")
ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, size=6) #만약 로드를 안 했다면 Cars93마다 MASS를 붙여야 한다.
ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, size=6, colour="blue")
ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, size=6)
ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(shape=21, size=6, fill="blue")
ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Price)) + geom_point(colour="grey", shape=21, size=6) # aes(x=Weight, y=MPG.highway, fill=Price)은 가격에 따라 색상을 다르게 채우겠다는 의미. 그런데 price가 numeric형이라 채도만 다르게 된다.
ggplot(Cars93, aes(x=Weight, y=MPG.highway)) + geom_point(colour="grey", shape=21, size=6, aes(fill=Price))
ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Cylinders)) +  geom_point(colour="grey", shape=21, size=6)
Cars93$Cylinders
class(Cars93$Cylinders)
class(Cars93$Price)
ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Cylinders)) +
geom_point(colour="grey", shape=21, size=6) +
scale_fill_brewer(palette="Oranges") # Oranges
ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Cylinders)) +
geom_point(colour="grey", shape=21, size=6) +
scale_fill_brewer(palette="Reds") # Reds
ggplot(Cars93, aes(x=Weight, y=MPG.highway, fill=Cylinders)) +
geom_point(colour="grey", shape=21, size=6) +
scale_fill_brewer(palette="Oranges") # Oranges
ggplot(data=w, aes(x=year)) + geom_bar() #geom_bar()는 빈도막대 그래프인데 년도별로 데이터가 여러개 있는게 아니라 각 년도마다 모든 데이터가 하나라 다 100%로 나온다.(의미없는 그래프)
w <- data.frame(year=c("2014", "2015", "2016", "2017", "2018"),
weight=c(65,66,64,68,72))
ggplot(data=w, aes(x=year)) + geom_bar() #geom_bar()는 빈도막대 그래프인데 년도별로 데이터가 여러개 있는게 아니라 각 년도마다 모든 데이터가 하나라 다 100%로 나온다.(의미없는 그래프)
ggplot(data=w, aes(x=year, y=weight)) + geom_bar() # 갯수를 세서 막대를 그리는게 기본이라.. 에러난다!!
# 범례 없애기
ggplot(mpg, aes(x=displ, y=hwy,  color= manufacturer))+
geom_point()+guides(color=F) #color에 F를 주면 범례를 나타내지 않는다.
# 범례 없애기
ggplot(mpg, aes(x=displ, y=hwy,  color= manufacturer))+
geom_point()+guides(color=None) #color에 F를 주면 범례를 나타내지 않는다.
# 범례 없애기
ggplot(mpg, aes(x=displ, y=hwy,  color= manufacturer))+
geom_point()+guides(color=none) #color에 F를 주면 범례를 나타내지 않는다.
w <- data.frame(year=c("2014", "2015", "2016", "2017", "2018"),
weight=c(65,66,64,68,72))
# 범례 열 갯수 설정
ggplot(mpg, aes(x=displ, y=hwy,  color= manufacturer))+
geom_point()+ scale_color_brewer(palette="Reds")+ guides(color = guide_legend(ncol = 2))  #범례를 2개 열로 나눠서 표현한다.
# 범례 없애기
ggplot(mpg, aes(x=displ, y=hwy,  color= manufacturer))+
geom_point()+guides(color="none") #color에 'none'를 주면 범례를 나타내지 않는다.
x
p1 <- ggplot(data = iris, aes(x = Petal.Width, y= Petal.Length, col=Species)) + geom_point()
p1
iris
library(gridExtra)
grid.arrange(p1, p2, nrow = 2)
grid.arrange(p1, p2, nrow = 2)
grid.arrange(p1, p2, ncol = 2)
p1 <- ggplot(data = iris, aes(x = Petal.Width, y= Petal.Length, col=Species)) + geom_point() #iris는 R의 내장 데이터셋
p2 <- ggplot(data = iris, aes(x = Sepal.Width, y= Sepal.Length, col=Species)) + geom_point()
grid.arrange(p1, p2, p1, p2, nrow = 2) #p1과 p2가 갖고있는 그래프를 2번씩 내보낸다. nrow=2를 주면 2행2열이 된다. 즉 여러개의 그래프를 2행2열로 레이아웃을 나눠서 그래프를 그린다.
grid.arrange(p1, p2, nrow = 2)
grid.arrange(p1, p2, ncol = 2)
library(plotly)
# ggplot으로 그래프 만들기
p <- ggplot(data = mpg, aes(x = displ, y = hwy, col = drv)) + geom_point()
p
# 인터랙티브 그래프 만들기
ggplotly(p)
mpg
p
str(mpg)
clarity
diamonds
sales_df <- read.xlsx("data/data.xlsx", 2, encoding="UTF-8")
# 트리맵 그리기
# index에 표현하고 싶은 계층 순서대로 벡터로 생성. product, region 순으로 벡터를 지정함으로써
# product가 region보다 더 상위로 구분이 됨
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple") #maple은 폰트이름이다.
# 트리맵 메모리 로드
library(treemap)
sales_df <- read.xlsx("data/data.xlsx", 2, encoding="UTF-8") #엑셀파일의 sheet2
# 트리맵 그리기
# index에 표현하고 싶은 계층 순서대로 벡터로 생성. product, region 순으로 벡터를 지정함으로써
# product가 region보다 더 상위로 구분이 됨
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple") #maple은 폰트이름이다.
# 트리맵 그리기
treemap(sales_df, vSize="saleAmt", index=c("region", "product"), title="A기업 판매현황", fontfamily.title="dog", fontfamily.labels="dog")
dev.copy(png, "output/test.png")
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple")
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple")
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple")
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple")
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple")
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple")
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple")
treemap(sales_df, vSize="saleAmt", index=c("product", "region"), title="A기업 판매현황", fontfamily.title="maple", fontfamily.labels="maple")
#11월 14일 실습1
#exam11.R 관련 내용
#[문제1]
#score.csv 를 읽고 student 라는 데이터프레임을 생성한다. class 컬럼의 값을 팩터형으로 변환한다.
#class 컬럼의 값별로 칼라를 지정하여 수학 점수와 과학 점수에 대한 산점도를 그린다.
student <- read.csv("data/score.csv")
student
ggplot(mpg,aes(displ, hwy))  #x 축은 displ, y축은 hwy #Grid는 기본적으로 설정됨.
ggplot(mpg,aes(displ, hwy)) + geom_point() #데이터들에 점을 찍는다.
ggplot(student,aes(math, science)) + geom_point()
sketch <- ggplot(data = mpg, aes(x = displ, y = hwy)) #x 축은 displ, y축은 hwy라는 데이터계층을 미리 호출을 해서 밑바탕이 되는 데이터레이어만 그려지는데 이렇게 변수에 담는 경우는 화면(Plots)에 보이지 않는다.(뭔소린지 이해가..)
str(sketch)
sketch + geom_point() #데이터가 점으로 표시된다.
sketch + geom_line(color="green") #데이터를 점이 아닌 초록선 선으로 이어서 보여준다.
sketch + geom_point() + xlim(3, 6) #x축 범위를 지정해서 범위 밖의 데이터는 잘라낸다.
sketch + geom_point() + ylim(10, 30) #y축 범위를 지정해서 범위 밖의 데이터는 잘라낸다.
sketch + geom_point() + xlim(3, 6) + ylim(10, 30)
sketch + geom_point(size=3) + coord_cartesian(xlim=c(3, 6), ylim=c(10, 30)) #x축과 y축의 범위는 '+' 연산자로 주던가 coord_cartesian()이라는 함수의 argument로 x축과 y축의 범위를 주는 것도 가능하다.
sketch + geom_point(aes(color=drv)) #sketch라는 변수 안에는 리스트 객체가 들어있는데 aes() ~~~
ggplot(student,aes(math, science, color=class)) + geom_point()
ggplot(student,aes(math, science, color=factor(class))) + geom_point()
ggplot(student,aes(math, science, color=as.factor(class))) + geom_point()
summary(factor(mtcars$cyl)) #mtcars$cyl가 숫자이지만 factor()를 이용해서 범주형으로 바꾼다. 이 때는 as.factor하나 factor하나 결과는 같다고 한다.
summary(mtcars$cyl) #summary함수는 numeric 함수면 최솟값, 1분위, 중간, 평균, 3분위, 최댓값을 출력한다.
summary(factor(mtcars$cyl)) #mtcars$cyl가 숫자이지만 factor()를 이용해서 범주형으로 바꾼다. 이 때는 as.factor하나 factor하나 결과는 같다고 한다.
ggplot(mtcars, aes(x=cyl)) + geom_bar() #geom_bar는 카운트해서 바 그래프 그려주는 거다. #x축값이 3초과5미만으로 표현된 첫번째 그래프는 실린더 4개짜리인 것 같다.
ggplot(mtcars, aes(x=cyl)) + geom_bar(width=0.5) #width는 너비값인가?
ggplot(mtcars, aes(x=cyl, fill=factor(gear))) + geom_bar(alpha=0.5) #fill=factor(gear)은 gear 데이터값으로 채우는데 그 값을 numeric으로 인식하지말고 factor로 인식하라는 것이다.
ggplot(mtcars, aes(x=cyl)) + geom_bar(aes(fill=factor(gear)), alpha=1.0) #alpha는 투명도를 의미한다. 0.0은 완전투명, 1.0은 완전 불투명 #fill=factor(gear)를 geom_bar의 매개변수로 줬다.
ggplot(airquality, aes(x=Day, y=Temp, col=factor(Month))) + geom_point(size=2) #다만 이렇게 색상을 다르게 적용할때는 aes()에 넣어줘야 한다. #만약 factor(Month)가 아닌 그냥 col=Month를 하면 다양한 유채색이 아닌 진한 색상과 흐린 색상으로 데이터를 구분한다. #연속적인 수치데이터를 가지고 색상으로 구분하겠다면 factor(Month)처럼 해줘야 한다. 그럼 개별적인 수치 데이터라는 뜻으로 완전 다른 색상으로 데이터 종류를 구분한다. #geom_point로 점의 크기를 2로 지정한다.
factor
ggplot(mtcars, aes(x=cyl, fill=factor(gear))) + geom_bar(alpha=0.5) #fill=factor(gear)은 gear 데이터값으로 채우는데 그 값을 numeric으로 인식하지말고 factor로 인식하라는 것이다.
ggplot(student,aes(math, science, color=as.factor(class))) + geom_point()
#11월 14일 실습1
#exam11.R 관련 내용
#[문제1]
#score.csv 를 읽고 student 라는 데이터프레임을 생성한다. class 컬럼의 값을 팩터형으로 변환한다.
#class 컬럼의 값별로 칼라를 지정하여 수학 점수와 과학 점수에 대한 산점도를 그린다.
student <- read.csv("data/score.csv")
student$class <- as.factor(student$class)
class(student$class)
class(student)
str(student)
ggplot(student,aes(math, science, color=class)) + geom_point()
ggplot(student,aes(math, science)) + geom_point() #x축과 y축을 지정하고 범례를 정한다음
str(student)
student
