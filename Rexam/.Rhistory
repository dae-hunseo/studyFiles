stop("벡터만 처리 가능!")
return()
}
}
result = mySum(c())
result = mySum(8)
result = mySum(c(2,5,8, 10))
result = mySum(c(1,NA,8))
mySum(c(2,5,8, 10))
mySum(c(2,5,8, 10))
mySum(c(2,5,8, 10))
mySum(c(2,5,8, 10))
result = mySum(list(1,3,5))
mySum(c(1,3,5))
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
for(i in 1:length(v)){
#try(if(any(is.na(v))){
#  warning("NA를 최저값으로 변경하여 처리함!!")
#  v[i] = min(v) #최솟값 설정.
#})
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
result = mySum(c())
result = mySum(8)
mySum(c())
mySum(8)
mySum(c(2,5,8, 10))
mySum(c(1,NA,8))
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
for(i in 1:length(v)){
try(if(any(is.na(v))){
warning("NA를 최저값으로 변경하여 처리함!!")
v[i] = min(v) #최솟값 설정.
})
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
mySum(c())
mySum(8)
mySum(c(2,5,8, 10))
mySum(c(1,NA,8))
mySum(c(1,3,5))
mySum(list(1,3,5))
mySum(list(1,3,5))
min(c(1,5,7,10))
length(c(2,5,8,10))
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
for(i in 1:length(v)){
try(if(any(is.na(v))){
warning("NA를 최저값으로 변경하여 처리함!!");
v[i] = min(v); #최솟값 설정.
})
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
mySum(c())
mySum(8)
mySum(c(2,5,8, 10))
mySum(c(1,NA,8))
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
for(i in 1:length(v)){
if(any(is.na(v))){
warning("NA를 최저값으로 변경하여 처리함!!");
v[i] = min(v); #최솟값 설정.
}
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
mySum(c())
mySum(8)
mySum(c(2,5,8, 10))
mySum(c(1,NA,8))
mySum(list(1,3,5))
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
for(i in 1:length(v)){
if(is.na(v[i])){
warning("NA를 최저값으로 변경하여 처리함!!");
v[i] = min(v); #최솟값 설정.
}
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
mySum(c())
mySum(8)
mySum(c(2,5,8, 10))
mySum(c(1,NA,8))
mySum(list(1,3,5))
mySum(c(1,NA,8))
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
for(i in 1:length(v)){
if(is.na(v[i])){
warning("NA를 최저값으로 변경하여 처리함!!");
cat(v[i],"번째가 NA")
v[i] = min(v); #최솟값 설정.
}
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
mySum(c(1,NA,8))
vt = c(3,67,NA,20)
is.na(v[i])
vt = c(3,67,NA,20)
is.na(vt[3])
vt = c(3,67,NA,20)
is.na(vt[2])
vt = c(3,67,NA,20)
is.na(vt[3])
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
if(is.na(v)){
warning("NA를 최저값으로 변경하여 처리함!!");
v[is.na(v)] = min(v)
}
for(i in 1:length(v)){
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
mySum(c())
mySum(8)
mySum(c(2,5,8, 10))
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
if(is.na(v)){
warning("NA를 최저값으로 변경하여 처리함!!");
v[is.na(v)] = min(v)
}
for(i in 1:length(v)){
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
mySum(c())
mySum(8)
mySum(c(2,5,8, 10))
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
if(any(is.na(v))){
warning("NA를 최저값으로 변경하여 처리함!!");
v[is.na(v)] = min(v)
}
for(i in 1:length(v)){
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
mySum(c())
mySum(8)
mySum(c(2,5,8, 10))
mySum(c(1,NA,8))
#문제4
mySum <- function(v){
oddSum <- 0 #홀수
evenSum <- 0 #짝수
if(is.null(v)){
print("NULL값 리턴")
return()
}
if(is.vector(v) && !is.list(v)){ #벡터이면서 리스트가 아닐때
if(any(is.na(v))){
warning("NA를 최저값으로 변경하여 처리함!!");
v[is.na(v)] = min(v, na.rm=T)
}
for(i in 1:length(v)){
if(i%%2){ #홀수
oddSum <- oddSum + v[i]
}
else{
evenSum <- evenSum + v[i]
}
}
return(list(oddS = oddSum, evenS = evenSum))
}else{
stop("벡터만 처리 가능!")
return()
}
}
mySum(c())
mySum(8)
mySum(c(2,5,8, 10))
mySum(c(1,NA,8))
mySum(list(1,3,5))
countEvenOdd <- function(numV) {
evenNum <- 0 #짝수
oddNum <- 0 #홀수
if(is.vector(numV) && !is.list(numV) && is.numeric(numV)){
for(i in numV){ #ifelse(i%%2==0, even<-even+1, odd<-odd+1)
if(i%%2)
oddNum <- oddNum+1
else
evenNum <- evenNum+1
}
return(list(evenNum=evenNum, oddNum=oddNum))
}
else
return()
}
countEvenOdd(c(1,3,4,6,8))
countEvenOdd(1:10)
countEvenOdd(LETTERS)
countEvenOdd(list(1,2,3,4,5))
countEvenOdd(matrix(1:9, nrow=3))
#답안 코드
myExpr <- function(p){
if(!is.function(p))
stop("수행 안할꺼임!!")
else{
imsi <<-sample(1:45, 6)
return(p(imsi))
}
}
myExpr(cat)
imsi
myExpr(cat)
imsi
myExpr(max)
imsi
myExpr(sum)
imsi
myExpr(mySum)
imsi
myExpr(cat)
myExpr(cat)
myExpr(cat)
myExpr(cat)
myExpr(cat)
imsi
imsi
imsi
imsi
myExpr(cat)
imsi
myExpr(cat)
imsi
myExpr(cat)
imsi
myExpr(cat)
imsi
myExpr(max)
imsi
myExpr(max)
imsi
myExpr(max)
imsi
myExpr(max)
imsi
myExpr(max)
imsi
myExpr(max)
imsi
myExpr(max)
imsi
myExpr(max)
imsi
library()
installed.packages()
installed.packages()
library()
library()
library()
library()
text$doc
library(rvest)
library(rvest)
url <- "http://unico2013.dothome.co.kr/crawling/tagstyle.html"
text <- read_html(url)
url <- "http://unico2013.dothome.co.kr/crawling/tagstyle.html"
text <- read_html(url)
url <- "http://unico2013.dothome.co.kr/crawling/tagstyle.html"
text <- read_html(url)
install.packages("rvest")
install.packages("XML")
install.packages("httr")
library(rvest)
library(rvest)
library(rvest)
url <- "http://unico2013.dothome.co.kr/crawling/tagstyle.html"
text <- read_html(url)
url <- "http://unico2013.dothome.co.kr/crawling/tagstyle.html"
text <- read_html(url)
url <- "http://unico2013.dothome.co.kr/crawling/tagstyle.html"
text <- read_html(url)
library(rvest)
install.packages("rvest")
library(rvest)
url <- "http://unico2013.dothome.co.kr/crawling/tagstyle.html"
text <- read_html(url)
html_nodes(text, "div")
library(rvest)
url <- "https://www.data.go.kr/tcs/dss/selectDataSetList.do" #직접 들어가서 오픈 API (9,501건) 리스트를 흝어보자. 게시글이 하나의 컨텐트다.
html <- read_html(url)
html
# 목록 아이템 추출
title <- html_text(html_nodes(html, "#apiDataList .title"))
title
title <- gsub("[[:cntrl:]]", "", title)
title
View(openapidf)
openapidf <- data.frame(title, desc)
desc <- html_text(html_nodes(html, "#apiDataList .ellipsis"))
desc
desc <- gsub("[[:cntrl:]]", "", desc) #\t, \r, \n 같은 것을 공백으로 대체해준다. #마지막 매개변수 desc는 52번째 라인에서 이미 사용됐다. 여기서 새로 생성한 게 아니다.
desc
openapidf <- data.frame(title, desc)
openapidf
View(openapidf)
write.csv(openapidf, "output/openapidf.csv")
url<- "http://movie.naver.com/movie/point/af/list.nhn?page=1"
html <- read_html(url)
html
nodes <- html_nodes(html, ".movie")
title <- html_text(nodes)
title
nodes <- html_nodes(html, ".title em")
point <- html_text(nodes)
point
nodes <- html_nodes(html, ".title")
review <- html_text(nodes, trim=TRUE)
review
nodes <- html_nodes(html, xpath='//*[@id="old_content"]/table/tbody/tr/td[2]/text()')
review <- html_text(nodes, trim=TRUE)
review
review <- review[seq(4,50,5)]
review
nodes <- html_nodes(html, xpath='//*[@id="old_content"]/table/tbody/tr/td[2]/text()')
review <- html_text(nodes, trim=TRUE)
review
review <- review[seq(4,50,5)]
review  #엔터문자 같은 것도 하나하나 자식 DOM객체로 인식하고 있어서 빈 문자열이 많이 나온다.
nodes <- html_nodes(html, xpath='//*[@id="old_content"]/table/tbody/tr/td[2]/text()')
review <- html_text(nodes, trim=TRUE)
review
review <- review[seq(4,50,5)]
review
url<- "http://movie.naver.com/movie/point/af/list.nhn?page=1"
html <- read_html(url)
html
# 영화제목
nodes <- html_nodes(html, ".movie")
title <- html_text(nodes)
title
# 영화평점
nodes <- html_nodes(html, ".title em")
point <- html_text(nodes)
point
# 영화 리뷰글 #CSS선택자 방식
nodes <- html_nodes(html, ".title")
review <- html_text(nodes, trim=TRUE)
review #직접 홈페이지에서 f12를 눌러보면 알겠지만 리뷰글만의 태그가 따로 없다. 그래서 영화제목, 평점, 신고까지 다 뽑아냈다. 이럴때는 CSS 선택자가 아닌 XPath를 써야 한다.
# 영화 리뷰글 #XPath 방식 #태그로 감싸지지 않은 내용을 꺼내겠다면 CSS 선택자로 못하고 이렇게 XPath 방식을 이용해야 한다. CSS는 태그만 노드로 인정하는 반면 XPAth는 태그뿐만 아니라 텍스트도 노드로 인정한다.
nodes <- html_nodes(html, xpath='//*[@id="old_content"]/table/tbody/tr/td[2]/text()')
review <- html_text(nodes, trim=TRUE)
review
review <- review[seq(4,50,5)] #리뷰글만 태그로 묶지 않았기 때문에 엔터문자도 자식 텍스트
review  #엔터문자 같은 것도 하나하나 자식 DOM객체로 인식하고 있어서 빈 문자열이 많이 나온다.
